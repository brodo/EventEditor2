// Generated by CoffeeScript 1.7.1
(function() {
  var addEvent, connectorLine, createSidebar, d3, dragConnector, enter, eventList, eventWindow, exit, getMainRect, update, _;

  d3 = require('d3');

  createSidebar = require('./sidebar.js');

  _ = require('lodash');

  eventList = [];

  window.connectionList = [];

  eventWindow = require('./event_window.js')(eventList, connectionList, function() {
    enter();
    exit();
    return update();
  });

  connectorLine = d3.svg.line().x(function(d) {
    return d.x;
  }).y(function(d) {
    return d.y;
  }).interpolate('linear');

  dragConnector = d3.behavior.drag().origin(function(d) {
    return d.nodes[1];
  }).on("drag", function(d) {
    d.nodes[1].x = Math.max(0, d3.event.x);
    d.nodes[1].y = Math.max(0, d3.event.y);
    d.middleHasBeenDragged = true;
    d3.select(this.parentElement).moveToFront();
    return update();
  });

  update = function() {
    eventWindow.update(eventList);
    connectionList.forEach(function(e) {
      var end, middle, newMiddle, source, start, target, _ref;
      _ref = e.nodes, start = _ref[0], middle = _ref[1], end = _ref[2];
      source = eventList[e.source];
      if (e.type === "and") {
        start.x = source.andRectMiddle().x;
        start.y = source.andRectMiddle().y;
      } else {
        start.x = source.followedByRectMiddle().x;
        start.y = source.followedByRectMiddle().y;
      }
      if (!e.middleHasBeenDragged) {
        newMiddle = d3.interpolateObject(start, end)(0.5);
        middle.x = newMiddle.x;
        middle.y = newMiddle.y;
      }
      if (e.target !== null) {
        target = eventList[e.target];
        if (e.type === "and") {
          end.x = target.andRectMiddle().x;
          return end.y = target.andRectMiddle().y;
        } else {
          end.x = target.followedByRectMiddle().x;
          return end.y = target.followedByRectMiddle().y;
        }
      }
    });
    d3.selectAll('.connectorPath').data(connectionList).attr('d', function(d) {
      return connectorLine(d.nodes);
    });
    d3.selectAll('.connectorCircle').data(connectionList).attr('cx', function(d) {
      return d.nodes[1].x;
    }).attr('cy', function(d) {
      return d.nodes[1].y;
    });
    return d3.selectAll('.connectorText').data(connectionList).attr('x', function(d) {
      return d.nodes[1].x;
    }).attr('y', function(d) {
      return d.nodes[1].y;
    }).text(function(d) {
      if (d.type === "and") {
        return '⋀';
      } else {
        return '→';
      }
    });
  };

  enter = function() {
    var conn;
    eventWindow.enter(eventList);
    conn = d3.select('#svgMain').selectAll('.connector').data(connectionList).enter().append('g').attr('class', 'connector');
    conn.append('path').attr('class', 'connectorPath').attr('stroke', 'black').attr('stroke-width', 3).attr('fill', 'none').attr('d', function(d) {
      return connectorLine(d.nodes);
    });
    conn.append('circle').attr('class', 'connectorCircle').attr('cx', function(d) {
      return d.nodes[1].x;
    }).attr('cy', function(d) {
      return d.nodes[1].y;
    }).attr('r', 20).call(dragConnector);
    return conn.append('text').attr('class', 'connectorText').text(function(d) {
      if (d.type === "and") {
        return '⋀';
      } else {
        return '→';
      }
    }).attr('x', function(d) {
      return d.nodes[1].x;
    }).attr('y', function(d) {
      return d.nodes[1].y;
    }).attr('width', 15).attr('height', 15).call(dragConnector);
  };

  exit = function() {
    eventWindow.exit(eventList);
    return d3.selectAll('.connector').data(connectionList).exit().remove();
  };

  addEvent = function(d, x, y) {
    var data, parameter, _i, _len, _ref;
    data = _.cloneDeep(d);
    data.x = Math.max(0, x - getMainRect().left - 125);
    data.y = Math.max(0, y - getMainRect().top - 125);
    data.width = eventWindow.measures.eventWidth;
    data.height = eventWindow.measures.eventWidth;
    data.andRect = function() {
      return {
        x: this.x + 5,
        y: this.y + this.height - eventWindow.measures.eventTitleHeight + 5
      };
    };
    data.andRectMiddle = function() {
      return {
        x: this.andRect().x + eventWindow.measures.andCombinatorButtonWidth / 2,
        y: this.andRect().y + eventWindow.measures.andCombinatorButtonHeight / 2
      };
    };
    data.followedByRect = function() {
      return {
        x: this.x + 5 + eventWindow.measures.andCombinatorButtonWidth + 5,
        y: this.y + this.height - eventWindow.measures.eventTitleHeight + 5
      };
    };
    data.followedByRectMiddle = function() {
      return {
        x: this.followedByRect().x + eventWindow.measures.followedByCombinatorButtonWidth / 2,
        y: this.followedByRect().y + eventWindow.measures.followedByCombinatorButtonHeight / 2
      };
    };
    _ref = data.parameters;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      parameter = _ref[_i];
      parameter.conditions = [];
    }
    eventList.push(data);
    return enter();
  };

  getMainRect = function() {
    return d3.select('#svgMain').node().getBoundingClientRect();
  };

  enter();

  d3.json("data/sensors.json", createSidebar(addEvent));

}).call(this);
